package dev.syntax;

import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.time.LocalDate;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import dev.syntax.data.BookingDAO;
import dev.syntax.data.BookingRequest;
import dev.syntax.service.BookingService;
import dev.syntax.service.MailSender;
import dev.syntax.service.PaymentService;
import dev.syntax.service.RoomService;

import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.verify;
@ExtendWith(MockitoExtension.class)
public class Test07 {

  @InjectMocks // 목 객체들을 주입받아서 생성하는 객체
  private BookingService bookingService;
  @Mock // 해당 필드를 목 객체로 주입(Injection)
  private PaymentService paymentServiceMock;
  @Mock
  private RoomService roomServiceMock;
  @Mock
  private BookingDAO bookingDAOMock;
  @Mock
  private MailSender mailSenderMock;


  @Test
  @DisplayName("선결제(prepaid=true)일 경우 결제 서비스가 호출된다")
  void prepaid_true_calls_payment() {
      // Given
      BookingRequest bookingRequest = BookingRequest.builder()
          .guestCount(2)
          .dateFrom(LocalDate.of(2025, 1, 1))
          .dateTo(LocalDate.of(2025, 1, 3))
          .prepaid(true)
          .build();

      // given: 방 조회와 저장은 정상이라고 가정
      given(roomServiceMock.findAvailableRoomId(any()))
          .willReturn("1.1");
      given(bookingDAOMock.save(any()))
          .willReturn("BOOK-1");

      // When
      bookingService.makeBooking(bookingRequest);

      // Then
      verify(paymentServiceMock)
          .pay(eq(bookingRequest), anyDouble());
  }
}
